// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmgilman/go/exec"
	"io"
	"sync"
)

// Ensure, that ExecutorMock does implement exec.Executor.
// If this is not the case, regenerate this file with moq.
var _ exec.Executor = &ExecutorMock{}

// ExecutorMock is a mock implementation of exec.Executor.
//
//	func TestSomethingThatUsesExecutor(t *testing.T) {
//
//		// make and configure a mocked exec.Executor
//		mockedExecutor := &ExecutorMock{
//			CloneFunc: func() exec.Executor {
//				panic("mock out the Clone method")
//			},
//			RunFunc: func(args ...string) (*exec.Result, error) {
//				panic("mock out the Run method")
//			},
//			WithContextFunc: func(ctx context.Context) exec.Executor {
//				panic("mock out the WithContext method")
//			},
//			WithDirFunc: func(dir string) exec.Executor {
//				panic("mock out the WithDir method")
//			},
//			WithDisableColorsFunc: func() exec.Executor {
//				panic("mock out the WithDisableColors method")
//			},
//			WithEnvFunc: func(env map[string]string) exec.Executor {
//				panic("mock out the WithEnv method")
//			},
//			WithInheritEnvFunc: func() exec.Executor {
//				panic("mock out the WithInheritEnv method")
//			},
//			WithPassthroughFunc: func() exec.Executor {
//				panic("mock out the WithPassthrough method")
//			},
//			WithStderrFunc: func(w io.Writer) exec.Executor {
//				panic("mock out the WithStderr method")
//			},
//			WithStdoutFunc: func(w io.Writer) exec.Executor {
//				panic("mock out the WithStdout method")
//			},
//			WithTimeoutFunc: func(timeout string) exec.Executor {
//				panic("mock out the WithTimeout method")
//			},
//		}
//
//		// use mockedExecutor in code that requires exec.Executor
//		// and then make assertions.
//
//	}
type ExecutorMock struct {
	// CloneFunc mocks the Clone method.
	CloneFunc func() exec.Executor

	// RunFunc mocks the Run method.
	RunFunc func(args ...string) (*exec.Result, error)

	// WithContextFunc mocks the WithContext method.
	WithContextFunc func(ctx context.Context) exec.Executor

	// WithDirFunc mocks the WithDir method.
	WithDirFunc func(dir string) exec.Executor

	// WithDisableColorsFunc mocks the WithDisableColors method.
	WithDisableColorsFunc func() exec.Executor

	// WithEnvFunc mocks the WithEnv method.
	WithEnvFunc func(env map[string]string) exec.Executor

	// WithInheritEnvFunc mocks the WithInheritEnv method.
	WithInheritEnvFunc func() exec.Executor

	// WithPassthroughFunc mocks the WithPassthrough method.
	WithPassthroughFunc func() exec.Executor

	// WithStderrFunc mocks the WithStderr method.
	WithStderrFunc func(w io.Writer) exec.Executor

	// WithStdoutFunc mocks the WithStdout method.
	WithStdoutFunc func(w io.Writer) exec.Executor

	// WithTimeoutFunc mocks the WithTimeout method.
	WithTimeoutFunc func(timeout string) exec.Executor

	// calls tracks calls to the methods.
	calls struct {
		// Clone holds details about calls to the Clone method.
		Clone []struct {
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Args is the args argument value.
			Args []string
		}
		// WithContext holds details about calls to the WithContext method.
		WithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WithDir holds details about calls to the WithDir method.
		WithDir []struct {
			// Dir is the dir argument value.
			Dir string
		}
		// WithDisableColors holds details about calls to the WithDisableColors method.
		WithDisableColors []struct {
		}
		// WithEnv holds details about calls to the WithEnv method.
		WithEnv []struct {
			// Env is the env argument value.
			Env map[string]string
		}
		// WithInheritEnv holds details about calls to the WithInheritEnv method.
		WithInheritEnv []struct {
		}
		// WithPassthrough holds details about calls to the WithPassthrough method.
		WithPassthrough []struct {
		}
		// WithStderr holds details about calls to the WithStderr method.
		WithStderr []struct {
			// W is the w argument value.
			W io.Writer
		}
		// WithStdout holds details about calls to the WithStdout method.
		WithStdout []struct {
			// W is the w argument value.
			W io.Writer
		}
		// WithTimeout holds details about calls to the WithTimeout method.
		WithTimeout []struct {
			// Timeout is the timeout argument value.
			Timeout string
		}
	}
	lockClone             sync.RWMutex
	lockRun               sync.RWMutex
	lockWithContext       sync.RWMutex
	lockWithDir           sync.RWMutex
	lockWithDisableColors sync.RWMutex
	lockWithEnv           sync.RWMutex
	lockWithInheritEnv    sync.RWMutex
	lockWithPassthrough   sync.RWMutex
	lockWithStderr        sync.RWMutex
	lockWithStdout        sync.RWMutex
	lockWithTimeout       sync.RWMutex
}

// Clone calls CloneFunc.
func (mock *ExecutorMock) Clone() exec.Executor {
	if mock.CloneFunc == nil {
		panic("ExecutorMock.CloneFunc: method is nil but Executor.Clone was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClone.Lock()
	mock.calls.Clone = append(mock.calls.Clone, callInfo)
	mock.lockClone.Unlock()
	return mock.CloneFunc()
}

// CloneCalls gets all the calls that were made to Clone.
// Check the length with:
//
//	len(mockedExecutor.CloneCalls())
func (mock *ExecutorMock) CloneCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClone.RLock()
	calls = mock.calls.Clone
	mock.lockClone.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *ExecutorMock) Run(args ...string) (*exec.Result, error) {
	if mock.RunFunc == nil {
		panic("ExecutorMock.RunFunc: method is nil but Executor.Run was just called")
	}
	callInfo := struct {
		Args []string
	}{
		Args: args,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(args...)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedExecutor.RunCalls())
func (mock *ExecutorMock) RunCalls() []struct {
	Args []string
} {
	var calls []struct {
		Args []string
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// WithContext calls WithContextFunc.
func (mock *ExecutorMock) WithContext(ctx context.Context) exec.Executor {
	if mock.WithContextFunc == nil {
		panic("ExecutorMock.WithContextFunc: method is nil but Executor.WithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWithContext.Lock()
	mock.calls.WithContext = append(mock.calls.WithContext, callInfo)
	mock.lockWithContext.Unlock()
	return mock.WithContextFunc(ctx)
}

// WithContextCalls gets all the calls that were made to WithContext.
// Check the length with:
//
//	len(mockedExecutor.WithContextCalls())
func (mock *ExecutorMock) WithContextCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWithContext.RLock()
	calls = mock.calls.WithContext
	mock.lockWithContext.RUnlock()
	return calls
}

// WithDir calls WithDirFunc.
func (mock *ExecutorMock) WithDir(dir string) exec.Executor {
	if mock.WithDirFunc == nil {
		panic("ExecutorMock.WithDirFunc: method is nil but Executor.WithDir was just called")
	}
	callInfo := struct {
		Dir string
	}{
		Dir: dir,
	}
	mock.lockWithDir.Lock()
	mock.calls.WithDir = append(mock.calls.WithDir, callInfo)
	mock.lockWithDir.Unlock()
	return mock.WithDirFunc(dir)
}

// WithDirCalls gets all the calls that were made to WithDir.
// Check the length with:
//
//	len(mockedExecutor.WithDirCalls())
func (mock *ExecutorMock) WithDirCalls() []struct {
	Dir string
} {
	var calls []struct {
		Dir string
	}
	mock.lockWithDir.RLock()
	calls = mock.calls.WithDir
	mock.lockWithDir.RUnlock()
	return calls
}

// WithDisableColors calls WithDisableColorsFunc.
func (mock *ExecutorMock) WithDisableColors() exec.Executor {
	if mock.WithDisableColorsFunc == nil {
		panic("ExecutorMock.WithDisableColorsFunc: method is nil but Executor.WithDisableColors was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWithDisableColors.Lock()
	mock.calls.WithDisableColors = append(mock.calls.WithDisableColors, callInfo)
	mock.lockWithDisableColors.Unlock()
	return mock.WithDisableColorsFunc()
}

// WithDisableColorsCalls gets all the calls that were made to WithDisableColors.
// Check the length with:
//
//	len(mockedExecutor.WithDisableColorsCalls())
func (mock *ExecutorMock) WithDisableColorsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWithDisableColors.RLock()
	calls = mock.calls.WithDisableColors
	mock.lockWithDisableColors.RUnlock()
	return calls
}

// WithEnv calls WithEnvFunc.
func (mock *ExecutorMock) WithEnv(env map[string]string) exec.Executor {
	if mock.WithEnvFunc == nil {
		panic("ExecutorMock.WithEnvFunc: method is nil but Executor.WithEnv was just called")
	}
	callInfo := struct {
		Env map[string]string
	}{
		Env: env,
	}
	mock.lockWithEnv.Lock()
	mock.calls.WithEnv = append(mock.calls.WithEnv, callInfo)
	mock.lockWithEnv.Unlock()
	return mock.WithEnvFunc(env)
}

// WithEnvCalls gets all the calls that were made to WithEnv.
// Check the length with:
//
//	len(mockedExecutor.WithEnvCalls())
func (mock *ExecutorMock) WithEnvCalls() []struct {
	Env map[string]string
} {
	var calls []struct {
		Env map[string]string
	}
	mock.lockWithEnv.RLock()
	calls = mock.calls.WithEnv
	mock.lockWithEnv.RUnlock()
	return calls
}

// WithInheritEnv calls WithInheritEnvFunc.
func (mock *ExecutorMock) WithInheritEnv() exec.Executor {
	if mock.WithInheritEnvFunc == nil {
		panic("ExecutorMock.WithInheritEnvFunc: method is nil but Executor.WithInheritEnv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWithInheritEnv.Lock()
	mock.calls.WithInheritEnv = append(mock.calls.WithInheritEnv, callInfo)
	mock.lockWithInheritEnv.Unlock()
	return mock.WithInheritEnvFunc()
}

// WithInheritEnvCalls gets all the calls that were made to WithInheritEnv.
// Check the length with:
//
//	len(mockedExecutor.WithInheritEnvCalls())
func (mock *ExecutorMock) WithInheritEnvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWithInheritEnv.RLock()
	calls = mock.calls.WithInheritEnv
	mock.lockWithInheritEnv.RUnlock()
	return calls
}

// WithPassthrough calls WithPassthroughFunc.
func (mock *ExecutorMock) WithPassthrough() exec.Executor {
	if mock.WithPassthroughFunc == nil {
		panic("ExecutorMock.WithPassthroughFunc: method is nil but Executor.WithPassthrough was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWithPassthrough.Lock()
	mock.calls.WithPassthrough = append(mock.calls.WithPassthrough, callInfo)
	mock.lockWithPassthrough.Unlock()
	return mock.WithPassthroughFunc()
}

// WithPassthroughCalls gets all the calls that were made to WithPassthrough.
// Check the length with:
//
//	len(mockedExecutor.WithPassthroughCalls())
func (mock *ExecutorMock) WithPassthroughCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWithPassthrough.RLock()
	calls = mock.calls.WithPassthrough
	mock.lockWithPassthrough.RUnlock()
	return calls
}

// WithStderr calls WithStderrFunc.
func (mock *ExecutorMock) WithStderr(w io.Writer) exec.Executor {
	if mock.WithStderrFunc == nil {
		panic("ExecutorMock.WithStderrFunc: method is nil but Executor.WithStderr was just called")
	}
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockWithStderr.Lock()
	mock.calls.WithStderr = append(mock.calls.WithStderr, callInfo)
	mock.lockWithStderr.Unlock()
	return mock.WithStderrFunc(w)
}

// WithStderrCalls gets all the calls that were made to WithStderr.
// Check the length with:
//
//	len(mockedExecutor.WithStderrCalls())
func (mock *ExecutorMock) WithStderrCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockWithStderr.RLock()
	calls = mock.calls.WithStderr
	mock.lockWithStderr.RUnlock()
	return calls
}

// WithStdout calls WithStdoutFunc.
func (mock *ExecutorMock) WithStdout(w io.Writer) exec.Executor {
	if mock.WithStdoutFunc == nil {
		panic("ExecutorMock.WithStdoutFunc: method is nil but Executor.WithStdout was just called")
	}
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockWithStdout.Lock()
	mock.calls.WithStdout = append(mock.calls.WithStdout, callInfo)
	mock.lockWithStdout.Unlock()
	return mock.WithStdoutFunc(w)
}

// WithStdoutCalls gets all the calls that were made to WithStdout.
// Check the length with:
//
//	len(mockedExecutor.WithStdoutCalls())
func (mock *ExecutorMock) WithStdoutCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockWithStdout.RLock()
	calls = mock.calls.WithStdout
	mock.lockWithStdout.RUnlock()
	return calls
}

// WithTimeout calls WithTimeoutFunc.
func (mock *ExecutorMock) WithTimeout(timeout string) exec.Executor {
	if mock.WithTimeoutFunc == nil {
		panic("ExecutorMock.WithTimeoutFunc: method is nil but Executor.WithTimeout was just called")
	}
	callInfo := struct {
		Timeout string
	}{
		Timeout: timeout,
	}
	mock.lockWithTimeout.Lock()
	mock.calls.WithTimeout = append(mock.calls.WithTimeout, callInfo)
	mock.lockWithTimeout.Unlock()
	return mock.WithTimeoutFunc(timeout)
}

// WithTimeoutCalls gets all the calls that were made to WithTimeout.
// Check the length with:
//
//	len(mockedExecutor.WithTimeoutCalls())
func (mock *ExecutorMock) WithTimeoutCalls() []struct {
	Timeout string
} {
	var calls []struct {
		Timeout string
	}
	mock.lockWithTimeout.RLock()
	calls = mock.calls.WithTimeout
	mock.lockWithTimeout.RUnlock()
	return calls
}
